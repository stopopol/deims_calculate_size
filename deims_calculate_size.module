<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\node\Entity\Node;
use Drupal\geofield\GeoPHP\GeoPHPInterface;
use Drupal\Core\Plugin\DefaultPluginManager;

# this code requires laravel geometry: https://github.com/spinen/laravel-geometry
# install with
# sudo -HEu www-data php composer require spinen/laravel-geometry
# https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/function/hook_entity_presave/10

/**
 * Implements hook_entity_presave().
 */
function deims_calculate_size_entity_presave(Drupal\Core\Entity\EntityInterface $entity) {
	
	// only called when nodes are saved
	if ($entity->getEntityTypeId() == 'node') {
		
		// that are either sites or locations 
		if ($entity->getType() == "site" || $entity->getType() == "observation_location") {
			
			\Drupal::messenger()->addMessage('Node is either site or location', 'custom');
			
			// boundaries field needs to be filled
			if ($entity->get('field_boundaries')->getValue()) {
												
				$current_boundaries_content = json_decode(\Drupal::service('geofield.geophp')->load($entity->get('field_boundaries')->value)->out('json'));
				$old_boundaries_content = json_decode(\Drupal::service('geofield.geophp')->load($entity->original->get('field_boundaries')->value)->out('json'));
				
				\Drupal::messenger()->addMessage('and has boundaries', 'custom');
				
													
				// check if boundaries have changed from last save
				if ($current_boundaries_content != $old_boundaries_content) {
						
					\Drupal::messenger()->addMessage('Boundaries have changed', 'custom');
					$geom_type = $entity->get('field_boundaries')->geo_type;
					
					if ($geom_type == "Polygon" || $geom_type == "MultiPolygon") {
						
						$geo = new geoPHP();
						$mapper = new Spinen\Geometry\Support\TypeMapper();
						$geometry = new Spinen\Geometry\Geometry($geo, $mapper);
						
						if ($geom_type == "Polygon") {
							\Drupal::messenger()->addMessage('Boundaries are a Polygon', 'custom');
							$collection = $geometry->parseGeoJson($current_boundaries_content);
							$squareMeters = $collection->getSquareMeters();
							$boundaries_in_hectares = $squareMeters/10000;
							
						}
						
						if ($geom_type == "MultiPolygon") {
							// To do: loop for each polygon and adding up sizes
							\Drupal::messenger()->addMessage('Boundaries are a MultiPolygon', 'custom');
							
							$boundaries_in_hectares = 0;
							
							$collection = $geometry->parseGeoJson($current_boundaries_content);
							
							$polygons = $current_boundaries_content->coordinates;
				
							$geojson_multipolygon = $collection->toGeoJson();
							$geojson_array = json_decode($geojson_multipolygon);
							
							// this part doesn't work yet; need to figure out who to properly explode the geojson
							
							//\Drupal::messenger()->addMessage(array_keys($geojson_array), 'custom');
						
					
							
			
							//foreach ($polygon_array as $polygon) {
								
			
								
								
								//geoPHP::load("POINT($lon $lat)","wkt");
								// $ya200=geoPHP::load("POLYGON((41.51 12.3, 38.27 28.83, 32.55 41.84, 27.6 55.55, 29.54 71.37, 33.43 83.32, 36.6 94.92, 36.6 99.49, 35.17 111.45, 32.55 124.8, 35.17 130.78, 39.64 142.73, 43.58 152.58, 45.83 166.29, 56.17 163.83, 63.07 159.26, 68.66 154.69, 72.18 148.71, 75.93 140.63, 78.49 129.02, 80.3 114.26, 80.98 100.2, 81.2 87.54, 80.87 73.83, 79.62 59.41, 76.27 40.43, 71.07 28.13, 67.2 23.2, 63.55 20.04, 59.01 17.23, 54.16 15.12, 48.46 13.36,41.51 12.3))","wkt");

								//$collection = $geometry->parseGeoJson($polygon);
								//$squareMeters = $collection->getSquareMeters();
								//$current_size_in_hectares = $squareMeters/10000;
								//$boundaries_in_hectares = $boundaries_in_hectares + $current_size_in_hectares;
								//\Drupal::messenger()->addMessage($current_size_in_hectares, 'custom'); // object
							//}
							
						}
						
						if ($boundaries_in_hectares > 0) {
							$entity->field_size->value = $boundaries_in_hectares;
						}
												
					}
				}
			}
		}
	}
}
