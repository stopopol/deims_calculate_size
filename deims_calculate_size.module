<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\node\Entity\Node;
use Drupal\geofield\GeoPHP\GeoPHPInterface;
use Drupal\Core\Plugin\DefaultPluginManager;

# this code requires laravel geometry: https://github.com/spinen/laravel-geometry
# install it with
# sudo -HEu www-data php composer require spinen/laravel-geometry
# this module uses the entity_presave() hook to run whenever a location or site is created or updated:
# https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/function/hook_entity_presave/10

/**
 * Implements hook_entity_presave().
 */
function deims_calculate_size_entity_presave(Drupal\Core\Entity\EntityInterface $entity) {
	
	// only called when nodes are saved
	if ($entity->getEntityTypeId() == 'node') {
		
		// that are either sites or locations 
		if ($entity->getType() == "site" || $entity->getType() == "observation_location") {
			
			\Drupal::messenger()->addMessage('Node is either site or location', 'custom');
			
			// boundaries field needs to be filled
			if ($entity->get('field_boundaries')->getValue()) {
												
				$current_boundaries_content = json_decode(\Drupal::service('geofield.geophp')->load($entity->get('field_boundaries')->value)->out('json'));
				
				// catch case if node is created for the first time
				if ($entity->original) {
					// check if there are already boundaries 
					if ($entity->original->get('field_boundaries')->value) {
						$old_boundaries_content = json_decode(\Drupal::service('geofield.geophp')->load($entity->original->get('field_boundaries')->value)->out('json'));
					}
					else {
						$old_boundaries_content = "";
					}
				}
				else {
					$old_boundaries_content = "";
				}
				
				\Drupal::messenger()->addMessage('and has boundaries', 'custom');
													
				// check if boundaries have changed from last save
				if ($current_boundaries_content != $old_boundaries_content) {
						
					\Drupal::messenger()->addMessage('Boundaries have changed', 'custom');
					$geom_type = $entity->get('field_boundaries')->geo_type;
					
					if ($geom_type == "Polygon" || $geom_type == "MultiPolygon") {
						
						$geo = new geoPHP();
						$mapper = new Spinen\Geometry\Support\TypeMapper();
						$geometry = new Spinen\Geometry\Geometry($geo, $mapper);
						$collection = $geometry->parseGeoJson($current_boundaries_content);
						$boundaries_in_hectares = 0;
						
						if ($geom_type == "Polygon") {
							\Drupal::messenger()->addMessage('Boundaries are a Polygon', 'custom');
							$squareMeters = $collection->getSquareMeters();
							$boundaries_in_hectares = $squareMeters/10000;
						}
						
						if ($geom_type == "MultiPolygon") {
							
							\Drupal::messenger()->addMessage('Boundaries are a MultiPolygon', 'custom');
							
							$geojson_array = json_decode($collection->toGeoJson());
							
							// Loop for each polygon and adding up sizes
							foreach ($geojson_array->coordinates as $polygon) {
		
								$geoJson = '{"type":"Polygon", "coordinates":' . json_encode($polygon) . '}';
								$collection = $geometry->parseGeoJson($geoJson);
								$squareMeters = $collection->getSquareMeters();
								$boundaries_in_hectares = $boundaries_in_hectares + $squareMeters/10000;
								\Drupal::messenger()->addMessage($geoJson, 'custom');
																
							}
							
							\Drupal::messenger()->addMessage("$boundaries_in_hectares", 'custom');
									
						}
						
						if ($boundaries_in_hectares > 0) {
							// round the calculated total to two digits
							$entity->field_size->value = round($boundaries_in_hectares,2);
						}
												
					}
				}
			}
		}
	}
}
