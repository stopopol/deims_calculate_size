<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\node\Entity\Node;
use Drupal\geofield\GeoPHP\GeoPHPInterface;
use Drupal\Core\Plugin\DefaultPluginManager;

# this code requires laravel geometry: https://github.com/spinen/laravel-geometry
# install with
# sudo -HEu www-data php composer require spinen/laravel-geometry
# https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Entity%21entity.api.php/function/hook_entity_presave/10

/**
 * Implements hook_entity_presave().
 */
function deims_calculate_size_entity_presave(Drupal\Core\Entity\EntityInterface $entity) {
	
	// only called when nodes are saved
	if ($entity->getEntityTypeId() == 'node') {
		
		// that are either sites or locations 
		if ($entity->getType() == "site" || $entity->getType() == "observation_location") {
			
			\Drupal::messenger()->addMessage('Node is either site or location', 'custom');
			
			// boundaries field needs to be filled
			if ($entity->get('field_boundaries')->getValue()) {
												
				$current_boundaries_content = json_decode(\Drupal::service('geofield.geophp')->load($entity->get('field_boundaries')->value)->out('json'));
				$old_boundaries_content = json_decode(\Drupal::service('geofield.geophp')->load($entity->original->get('field_boundaries')->value)->out('json'));
				
				\Drupal::messenger()->addMessage('and has boundaries', 'custom');
				
													
				// check if boundaries have changed from last save
				if ($current_boundaries_content != $old_boundaries_content) {
						
					\Drupal::messenger()->addMessage('Boundaries have changed', 'custom');
					$geom_type = $entity->get('field_boundaries')->geo_type;
					
					if ($geom_type == "Polygon" || $geom_type == "MultiPolygon") {
						
						$geo = new geoPHP();
						$mapper = new Spinen\Geometry\Support\TypeMapper();
						$geometry = new Spinen\Geometry\Geometry($geo, $mapper);
						
						$boundaries_in_hectares = 0;
						
						if ($geom_type == "Polygon") {
							\Drupal::messenger()->addMessage('Boundaries are a Polygon', 'custom');
							$collection = $geometry->parseGeoJson($current_boundaries_content);
							$squareMeters = $collection->getSquareMeters();
							$boundaries_in_hectares = $squareMeters/10000;
						}
						
						if ($geom_type == "MultiPolygon") {
							
							\Drupal::messenger()->addMessage('Boundaries are a MultiPolygon', 'custom');
							
							$collection = $geometry->parseGeoJson($current_boundaries_content);
											
							$geojson_multipolygon = $collection->toGeoJson();
							$geojson_array = json_decode($geojson_multipolygon);
							
							$list_of_polygons = $geojson_array->coordinates;
							$polygon_array_keys = array_keys($list_of_polygons);

							// Loop for each polygon and adding up sizes
							foreach ($polygon_array_keys as $key) {
		
								$current_polygon = $list_of_polygons[$key]; // current polygon is an array
								$geoJson = '{"type":"Polygon", "coordinates":' . json_encode($current_polygon) . '}';
								$collection = $geometry->parseGeoJson($geoJson);
								$squareMeters = $collection->getSquareMeters();
								$boundaries_in_hectares = $boundaries_in_hectares + $squareMeters/10000;
								\Drupal::messenger()->addMessage($geoJson, 'custom');
								
								\Drupal::messenger()->addMessage(serialize($current_polygon), 'custom');
								
							}
							
							$output = "$boundaries_in_hectares";
							\Drupal::messenger()->addMessage($output, 'custom');
									
						}
						
						if ($boundaries_in_hectares > 0) {
							// round to two digits
							$entity->field_size->value = round($boundaries_in_hectares,2);
						}
												
					}
				}
			}
		}
	}
}
